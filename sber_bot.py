# -*- coding: utf-8 -*-
import os
import logging
import pandas as pd
import numpy as np
from datetime import timedelta
from tinkoff.invest import Client
from tinkoff.invest.schemas import CandleInterval
from telegram import Update
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes

# =========================
# –ö–æ–Ω—Ñ–∏–≥
# =========================
BOT_VERSION = "v0.14 ‚Äî strict BUY/SELL + directional DI emojis"
TINKOFF_API_TOKEN = os.getenv("TINKOFF_API_TOKEN")
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")

FIGI = "BBG004730N88"             # SBER
TF = CandleInterval.CANDLE_INTERVAL_HOUR
LOOKBACK_HOURS = 200
TRAIL_PCT = 0.015

# –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—à—å)
position_type = None   # "long" / "short" / None
entry_price = None
best_price = None
trailing_stop = None

# –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
log = logging.getLogger("sber-bot")

# =========================
# –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã (Wilder ADX)
# =========================
def ema(series: pd.Series, period: int) -> pd.Series:
    return series.ewm(span=period, adjust=False).mean()

def compute_adx(high: pd.Series, low: pd.Series, close: pd.Series, period: int = 14):
    prev_close = close.shift(1)
    up_move = high.diff()
    down_move = low.shift(1) - low  # –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –¥–≤–∏–∂–µ–Ω–∏–µ –≤–Ω–∏–∑

    plus_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0.0)
    minus_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0.0)

    tr = pd.concat([
        (high - low),
        (high - prev_close).abs(),
        (low - prev_close).abs()
    ], axis=1).max(axis=1)

    # Wilder smoothing —á–µ—Ä–µ–∑ EWM —Å alpha=1/period
    atr = tr.ewm(alpha=1/period, adjust=False).mean()
    plus_di = 100 * (pd.Series(plus_dm, index=high.index).ewm(alpha=1/period, adjust=False).mean() / atr)
    minus_di = 100 * (pd.Series(minus_dm, index=high.index).ewm(alpha=1/period, adjust=False).mean() / atr)

    dx = 100 * (plus_di.subtract(minus_di).abs() / (plus_di + minus_di))
    adx = dx.ewm(alpha=1/period, adjust=False).mean()
    return adx, plus_di, minus_di

# =========================
# –î–∞–Ω–Ω—ã–µ
# =========================
def get_candles() -> pd.DataFrame:
    if not TINKOFF_API_TOKEN:
        raise RuntimeError("–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TINKOFF_API_TOKEN –Ω–µ –∑–∞–¥–∞–Ω–∞.")
    with Client(TINKOFF_API_TOKEN) as client:
        now = pd.Timestamp.now(tz="Europe/Moscow")
        candles = client.market_data.get_candles(
            figi=FIGI,
            from_=now - pd.Timedelta(hours=LOOKBACK_HOURS),
            to=now,
            interval=TF
        ).candles

    df = pd.DataFrame([{
        "time": c.time,
        "open": c.open.units + c.open.nano / 1e9,
        "high": c.high.units + c.high.nano / 1e9,
        "low":  c.low.units  + c.low.nano  / 1e9,
        "close":c.close.units+ c.close.nano / 1e9,
        "volume": c.volume
    } for c in candles])
    return df

# =========================
# –û—Ü–µ–Ω–∫–∞ —É—Å–ª–æ–≤–∏–π –∏ —Å–∏–≥–Ω–∞–ª
# =========================
def evaluate_signal(df: pd.DataFrame):
    df = df.copy()
    df["ema100"] = ema(df["close"], 100)
    df["ADX"], df["+DI"], df["-DI"] = compute_adx(df["high"], df["low"], df["close"], period=14)
    df["vol_ma20"] = df["volume"].rolling(20).mean()

    last = df.iloc[-1]

    adx_cond = last["ADX"] > 23
    vol_cond = last["volume"] > last["vol_ma20"]

    # –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ BUY
    di_buy = last["+DI"] > last["-DI"]
    ema_buy = last["close"] > last["ema100"]

    # –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ SELL
    di_sell = last["-DI"] > last["+DI"]
    ema_sell = last["close"] < last["ema100"]

    buy_ok = adx_cond and di_buy and vol_cond and ema_buy
    sell_ok = adx_cond and di_sell and vol_cond and ema_sell

    if buy_ok:
        signal = "BUY"
    elif sell_ok:
        signal = "SELL"
    else:
        signal = None

    return last, {
        "adx_cond": adx_cond,
        "vol_cond": vol_cond,
        "di_buy": di_buy,
        "ema_buy": ema_buy,
        "di_sell": di_sell,
        "ema_sell": ema_sell,
        "signal": signal,
        "vol_ma20": last["vol_ma20"]
    }, df

# =========================
# –¢—Ä–µ–π–ª–∏–Ω–≥ (–µ—Å–ª–∏ –Ω–∞–¥–æ)
# =========================
def update_trailing(curr_price: float):
    global trailing_stop, best_price, position_type
    if position_type == "long":
        best_price = max(best_price or curr_price, curr_price)
        trailing_stop = best_price * (1 - TRAIL_PCT)
    elif position_type == "short":
        best_price = min(best_price or curr_price, curr_price)
        trailing_stop = best_price * (1 + TRAIL_PCT)

# =========================
# –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
# =========================
def emoji(ok: bool) -> str:
    return "‚úÖ" if ok else "‚ùå"

def build_message(last: pd.Series, conds: dict) -> str:
    global position_type, entry_price, trailing_stop

    price = last["close"]
    adx = last["ADX"]
    plus_di = last["+DI"]
    minus_di = last["-DI"]
    ema100 = last["ema100"]
    vol = last["volume"]
    vol_ma20 = conds["vol_ma20"]

    # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã + –ø–æ—Ä–æ–≥–∏
    lines = []
    lines.append("üìä –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:")
    lines.append(f"ADX: {adx:.2f} {emoji(conds['adx_cond'])} (–ø–æ—Ä–æ–≥ > 23)")
    lines.append(f"–û–±—ä—ë–º: {int(vol)} {emoji(conds['vol_cond'])} (MA20 = {int(vol_ma20)})")

    # EMA ‚Äî –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–ø–æ–∫–∞–∂–µ–º –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã)
    lines.append(f"EMA100: {ema100:.2f} | BUY: {emoji(conds['ema_buy'])} (—Ü–µ–Ω–∞ {price:.2f} > EMA) | SELL: {emoji(conds['ema_sell'])} (—Ü–µ–Ω–∞ {price:.2f} < EMA)")

    # DI ‚Äî —Ç–æ–∂–µ –≤ –æ–±–µ —Å—Ç–æ—Ä–æ–Ω—ã
    lines.append(f"+DI / -DI: {plus_di:.2f} / {minus_di:.2f} | BUY: {emoji(conds['di_buy'])} (+DI > -DI) | SELL: {emoji(conds['di_sell'])} (-DI > +DI)")

    # –ò—Ç–æ–≥–æ–≤—ã–π —Å–∏–≥–Ω–∞–ª
    if conds["signal"] == "BUY":
        lines.append("\n‚úÖ –°–∏–≥–Ω–∞–ª —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: BUY")
    elif conds["signal"] == "SELL":
        lines.append("\n‚úÖ –°–∏–≥–Ω–∞–ª —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏: SELL")
    else:
        lines.append("\n‚ùå –°–∏–≥–Ω–∞–ª–æ–≤ –ø–æ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–µ—Ç")

    # –ë–ª–æ–∫ –ø–æ –ø–æ–∑–∏—Ü–∏–∏
    if position_type and entry_price:
        if position_type == "long":
            pnl = (price - entry_price) / entry_price * 100
        else:  # short
            pnl = (entry_price - price) / entry_price * 100
        ts_text = f"{trailing_stop:.2f}" if trailing_stop else "-"
        lines.append(f"\n–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {price:.2f}")
        lines.append(f"–¢–∏–ø –ø–æ–∑–∏—Ü–∏–∏: {position_type}")
        lines.append(f"–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: {entry_price:.2f}")
        lines.append(f"–¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø: {ts_text}")
        lines.append(f"–¢–µ–∫—É—â–∞—è –ø—Ä–∏–±—ã–ª—å: {pnl:.2f}%")
    else:
        lines.append(f"\n–¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: {price:.2f}")
        lines.append("–¢–∏–ø –ø–æ–∑–∏—Ü–∏–∏: -")
        lines.append("–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: -")
        lines.append("–¢—Ä–µ–π–ª–∏–Ω–≥-—Å—Ç–æ–ø: -")
        lines.append("–¢–µ–∫—É—â–∞—è –ø—Ä–∏–±—ã–ª—å: -")

    lines.append(f"\nüß© –í–µ—Ä—Å–∏—è –±–æ—Ç–∞: {BOT_VERSION}")
    return "\n".join(lines)

# =========================
# Telegram Handlers
# =========================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text=f"üò∫ –†–µ–≤—É—â–∏–π –∫–æ—Ç—ë–Ω–æ–∫ –Ω–∞ —Å–≤—è–∑–∏! –ë—É–¥—É –ø—Ä–∏—Å—ã–ª–∞—Ç—å —Å–∏–≥–Ω–∞–ª—ã –ø–æ SBER\n–í–µ—Ä—Å–∏—è: {BOT_VERSION}"
    )

async def signal_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        df = get_candles()
        last, conds, _ = evaluate_signal(df)
        msg = build_message(last, conds)
        await context.bot.send_message(chat_id=update.effective_chat.id, text=msg)
    except Exception as e:
        log.exception("–û—à–∏–±–∫–∞ –≤ /signal")
        await context.bot.send_message(chat_id=update.effective_chat.id, text=f"–û—à–∏–±–∫–∞: {e}")

# =========================
# Main
# =========================
def main():
    if not TELEGRAM_TOKEN:
        raise RuntimeError("–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä—É–∂–µ–Ω–∏—è TELEGRAM_TOKEN –Ω–µ –∑–∞–¥–∞–Ω–∞.")
    app = ApplicationBuilder().token(TELEGRAM_TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("signal", signal_cmd))
    app.run_polling()

if __name__ == "__main__":
    main()
