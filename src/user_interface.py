import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes

logger = logging.getLogger(__name__)

class UserInterface:
    """–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å –†–ï–ê–õ–¨–ù–´–ú–ò ADX –æ—Ç GPT"""
    
    def __init__(self, database, signal_processor, gpt_analyzer=None):
        self.db = database
        self.signal_processor = signal_processor
        self.gpt_analyzer = gpt_analyzer
        self.app = None
    
    def set_app(self, app):
        """–£—Å—Ç–∞–Ω–æ–≤–∫–∞ Telegram –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
        self.app = app
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start —Å –æ–ø–∏—Å–∞–Ω–∏–µ–º –†–ï–ê–õ–¨–ù–´–• ADX"""
        chat_id = update.effective_chat.id
        user = update.effective_user
        
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –ë–î
        success = await self.db.add_or_update_user(
            telegram_id=chat_id,
            username=user.username if user else None,
            first_name=user.first_name if user else None
        )
        
        if success:
            # –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ–¥–ø–∏—Å—ã–≤–∞–µ–º –Ω–∞ SBER
            await self.db.subscribe_user_to_ticker(chat_id, 'SBER')
            
            gpt_status = "ü§ñ <b>GPT —Å –†–ï–ê–õ–¨–ù–´–ú ADX:</b> –≤–∫–ª—é—á–µ–Ω" if self.gpt_analyzer else "üìä <b>–†–µ–∂–∏–º:</b> —Ç–æ–ª—å–∫–æ EMA20"
            
            await update.message.reply_text(
                "üê± <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –†–µ–≤—É—â–µ–≥–æ –∫–æ—Ç—ë–Ω–∫–∞!</b>\n\n"
                "üìà –í—ã –ø–æ–¥–ø–∏—Å–∞–Ω—ã –Ω–∞ —Ç–æ—Ä–≥–æ–≤—ã–µ —Å–∏–≥–Ω–∞–ª—ã\n"
                "üîî –ö–æ—Ç—ë–Ω–æ–∫ —Å–æ–æ–±—â–∏—Ç –æ —Å–∏–≥–Ω–∞–ª–∞—Ö –ø–æ–∫—É–ø–∫–∏/–ø—Ä–æ–¥–∞–∂–∏\n\n"
                f"{gpt_status}\n\n"
                "<b>üéØ –£–ú–ù–ê–Ø –°–¢–†–ê–¢–ï–ì–ò–Ø:</b>\n"
                "‚Ä¢ üìä <b>EMA20</b> - –±–∞–∑–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä —Ç—Ä–µ–Ω–¥–∞\n"
                "‚Ä¢ ü§ñ <b>GPT —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –†–ï–ê–õ–¨–ù–´–ô ADX</b>\n"
                "‚Ä¢ ‚úÖ <b>ADX > 25</b> - —Å–∏–ª—å–Ω—ã–π —Ç—Ä–µ–Ω–¥\n"
                "‚Ä¢ ‚úÖ <b>+DI > -DI</b> - –≤–æ—Å—Ö–æ–¥—è—â–µ–µ –¥–≤–∏–∂–µ–Ω–∏–µ\n"
                "‚Ä¢ ‚úÖ <b>–†–∞–∑–Ω–∏—Ü–∞ DI > 1</b> - –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è —Å–∏–ª–∞\n"
                "‚Ä¢ üî• <b>ADX > 45</b> - –ø–∏–∫ —Ç—Ä–µ–Ω–¥–∞, –ø—Ä–æ–¥–∞–≤–∞—Ç—å!\n\n"
                "<b>üì± –ö–æ–º–∞–Ω–¥—ã:</b>\n"
                "/stop - –æ—Ç–ø–∏—Å–∞—Ç—å—Å—è\n"
                "/signal - –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–∏–≥–Ω–∞–ª—ã —Å ADX\n"
                "/portfolio - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∫–∞–º–∏",
                parse_mode='HTML'
            )
            logger.info(f"üë§ –ü–æ–¥–ø–∏—Å—á–∏–∫: {chat_id}")
        else:
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                parse_mode='HTML'
            )
    
    async def stop_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /stop"""
        chat_id = update.effective_chat.id
        await self.db.deactivate_user(chat_id)
        
        await update.message.reply_text(
            "‚ùå <b>–í—ã –æ—Ç–ø–∏—Å–∞–ª–∏—Å—å –æ—Ç –∫–æ—Ç—ë–Ω–∫–∞</b>\n\n"
            "–í—Å–µ –ø–æ–∑–∏—Ü–∏–∏ –∑–∞–∫—Ä—ã—Ç—ã.\n"
            "–î–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /start",
            parse_mode='HTML'
        )
        logger.info(f"üë§ –û—Ç–ø–∏—Å–∫–∞: {chat_id}")
    
    async def portfolio_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª–µ–º"""
        chat_id = update.effective_chat.id
        subscriptions = await self.db.get_user_subscriptions(chat_id)
        available_tickers = await self.db.get_available_tickers()
        
        if subscriptions:
            sub_list = [f"üîî {sub['symbol']} ({sub['name']})" for sub in subscriptions]
            message = f"üìä <b>–í–ê–® –ü–û–†–¢–§–ï–õ–¨</b>\n\n<b>–ü–æ–¥–ø–∏—Å–∫–∏:</b>\n" + "\n".join(sub_list)
        else:
            message = "üìä <b>–í–ê–® –ü–û–†–¢–§–ï–õ–¨</b>\n\n<b>–£ –≤–∞—Å –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫</b>"
        
        keyboard = []
        subscribed_symbols = {sub['symbol'] for sub in subscriptions}
        
        for ticker in available_tickers:
            symbol = ticker['symbol']
            name = ticker['name']
            if symbol in subscribed_symbols:
                button_text = f"üîî {symbol} ({name}) ‚ùå"
                callback_data = f"unsub_{symbol}"
            else:
                button_text = f"‚ö™ {symbol} ({name}) ‚ûï"
                callback_data = f"sub_{symbol}"
            
            keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
    
    async def signal_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /signal —Å –†–ï–ê–õ–¨–ù–´–ú–ò ADX –æ—Ç GPT"""
        try:
            chat_id = update.effective_chat.id
            subscriptions = await self.db.get_user_subscriptions(chat_id)
            
            if not subscriptions:
                await update.message.reply_text(
                    "üìä <b>–£ –≤–∞—Å –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫</b>\n\n"
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /portfolio –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è",
                    parse_mode='HTML'
                )
                return
            
            # –ï—Å–ª–∏ –æ–¥–Ω–∞ –ø–æ–¥–ø–∏—Å–∫–∞ - —Å—Ä–∞–∑—É –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º
            if len(subscriptions) == 1:
                symbol = subscriptions[0]['symbol']
                name = subscriptions[0]['name']
                
                await update.message.reply_text(f"üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é {symbol} ({name}) —Å —Ä–∞—Å—á–µ—Ç–æ–º –†–ï–ê–õ–¨–ù–û–ì–û ADX...")
                
                signal = await self.signal_processor.analyze_market(symbol)
                
                if signal:
                    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –†–ï–ê–õ–¨–ù–´–ú–ò ADX –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                    message = f"""‚úÖ <b>–ê–ö–¢–ò–í–ù–´–ô –°–ò–ì–ù–ê–õ {symbol}</b>

üí∞ <b>–¶–µ–Ω–∞:</b> {signal.price:.2f} ‚ÇΩ
üìà <b>EMA20:</b> {signal.ema20:.2f} ‚ÇΩ

‚è∞ <b>–í—Ä–µ–º—è:</b> {signal.timestamp.strftime('%H:%M %d.%m.%Y')}"""
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º –†–ï–ê–õ–¨–ù–´–ï ADX –∑–Ω–∞—á–µ–Ω–∏—è –µ—Å–ª–∏ –µ—Å—Ç—å
                    if hasattr(signal, 'adx') and signal.adx > 0:
                        adx_status = "üü¢ –°–∏–ª—å–Ω—ã–π" if signal.adx >= 25 else "üî¥ –°–ª–∞–±—ã–π"
                        di_status = "üü¢ –í–æ—Å—Ö–æ–¥—è—â–∏–π" if signal.plus_di > signal.minus_di else "üî¥ –ù–∏—Å—Ö–æ–¥—è—â–∏–π"
                        
                        message += f"""

üìä <b>–†–ï–ê–õ–¨–ù–´–ô ADX –û–¢ GPT:</b>
‚Ä¢ <b>ADX:</b> {signal.adx:.1f} {adx_status} —Ç—Ä–µ–Ω–¥
‚Ä¢ <b>+DI:</b> {signal.plus_di:.1f}
‚Ä¢ <b>-DI:</b> {signal.minus_di:.1f} {di_status}
‚Ä¢ <b>–†–∞–∑–Ω–∏—Ü–∞:</b> {signal.plus_di - signal.minus_di:+.1f}"""
                    
                    # –î–æ–±–∞–≤–ª—è–µ–º GPT –∞–Ω–∞–ª–∏–∑
                    if self.gpt_analyzer:
                        try:
                            gpt_advice = await self._get_gpt_analysis_for_signal(signal)
                            if gpt_advice:
                                message += f"\n{self.gpt_analyzer.format_advice_for_telegram(gpt_advice, signal.symbol)}"
                            else:
                                message += "\n\nü§ñ <i>–î–µ—Ç–∞–ª—å–Ω—ã–π GPT –∞–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</i>"
                        except Exception as e:
                            logger.error(f"–û—à–∏–±–∫–∞ GPT –∞–Ω–∞–ª–∏–∑–∞: {e}")
                            message += "\n\nü§ñ <i>–î–µ—Ç–∞–ª—å–Ω—ã–π GPT –∞–Ω–∞–ª–∏–∑ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω</i>"
                else:
                    message = await self.signal_processor.get_detailed_market_status(symbol)
                
                await update.message.reply_text(message, parse_mode='HTML')
                return
            
            # –ï—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–¥–ø–∏—Å–æ–∫ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
            message = f"üîç <b>–ê–ù–ê–õ–ò–ó –°–ò–ì–ù–ê–õ–û–í –° –†–ï–ê–õ–¨–ù–´–ú ADX</b>\n\nüìä <b>–ü–æ–¥–ø–∏—Å–∫–∏ ({len(subscriptions)}):</b>\n–í—ã–±–µ—Ä–∏—Ç–µ –∞–∫—Ü–∏—é –¥–ª—è ADX –∞–Ω–∞–ª–∏–∑–∞:"
            
            keyboard = []
            for sub in subscriptions:
                symbol = sub['symbol']
                name = sub['name']
                keyboard.append([InlineKeyboardButton(f"üìä {symbol} ({name})", callback_data=f"analyze_{symbol}")])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ /signal: {e}")
            await update.message.reply_text(
                "‚ùå <b>–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å–∏–≥–Ω–∞–ª–æ–≤</b>\n\n–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                parse_mode='HTML'
            )

    async def handle_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ inline –∫–Ω–æ–ø–æ–∫"""
        query = update.callback_query
        chat_id = query.message.chat_id
        data = query.data
        
        if data.startswith("sub_"):
            symbol = data[4:]
            success = await self.db.subscribe_user_to_ticker(chat_id, symbol)
            
            if success:
                await query.answer(f"‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ {symbol} –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!")
                await self._update_portfolio_message(query)
            else:
                await query.answer("‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏", show_alert=True)
        
        elif data.startswith("unsub_"):
            symbol = data[6:]
            success = await self.db.unsubscribe_user_from_ticker(chat_id, symbol)
            
            if success:
                await query.answer(f"‚ùå –û—Ç–ø–∏—Å–∫–∞ –æ—Ç {symbol}")
                await self._update_portfolio_message(query)
            else:
                await query.answer("‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø–∏—Å–∫–∏", show_alert=True)
        
        elif data.startswith("analyze_"):
            symbol = data[8:]
            await self._analyze_single_ticker(query, symbol)
    
    async def _analyze_single_ticker(self, query, symbol: str):
        """–ê–Ω–∞–ª–∏–∑ –æ–¥–Ω–æ–π –∞–∫—Ü–∏–∏ —Å –†–ï–ê–õ–¨–ù–´–ú–ò ADX –æ—Ç GPT"""
        try:
            await query.answer()
            
            ticker_info = await self.db.get_ticker_info(symbol)
            name = ticker_info['name'] if ticker_info else symbol
            
            loading_message = await query.message.reply_text(f"üîç –ê–Ω–∞–ª–∏–∑–∏—Ä—É—é {symbol} ({name}) —Å —Ä–∞—Å—á–µ—Ç–æ–º –†–ï–ê–õ–¨–ù–û–ì–û ADX...")
            
            signal = await self.signal_processor.analyze_market(symbol)
            
            if signal:
                message = f"""‚úÖ <b>–ê–ö–¢–ò–í–ù–´–ô –°–ò–ì–ù–ê–õ {symbol}</b>

üí∞ <b>–¶–µ–Ω–∞:</b> {signal.price:.2f} ‚ÇΩ
üìà <b>EMA20:</b> {signal.ema20:.2f} ‚ÇΩ

‚è∞ <b>–í—Ä–µ–º—è:</b> {signal.timestamp.strftime('%H:%M %d.%m.%Y')}"""
                
                # –î–æ–±–∞–≤–ª—è–µ–º –†–ï–ê–õ–¨–ù–´–ï ADX –∑–Ω–∞—á–µ–Ω–∏—è
                if hasattr(signal, 'adx') and signal.adx > 0:
                    adx_status = "üü¢ –°–∏–ª—å–Ω—ã–π" if signal.adx >= 25 else "üî¥ –°–ª–∞–±—ã–π" 
                    di_status = "üü¢ –í–æ—Å—Ö–æ–¥—è—â–∏–π" if signal.plus_di > signal.minus_di else "üî¥ –ù–∏—Å—Ö–æ–¥—è—â–∏–π"
                    
                    message += f"""

üìä <b>–†–ï–ê–õ–¨–ù–´–ô ADX –û–¢ GPT:</b>
‚Ä¢ <b>ADX:</b> {signal.adx:.1f} {adx_status} —Ç—Ä–µ–Ω–¥
‚Ä¢ <b>+DI:</b> {signal.plus_di:.1f}
‚Ä¢ <b>-DI:</b> {signal.minus_di:.1f} {di_status}
‚Ä¢ <b>–†–∞–∑–Ω–∏—Ü–∞:</b> {signal.plus_di - signal.minus_di:+.1f}"""
                
                # –î–æ–±–∞–≤–ª—è–µ–º –¥–µ—Ç–∞–ª—å–Ω—ã–π GPT –∞–Ω–∞–ª–∏–∑
                if self.gpt_analyzer:
                    try:
                        gpt_advice = await self._get_gpt_analysis_for_signal(signal)
                        if gpt_advice:
                            message += f"\n{self.gpt_analyzer.format_advice_for_telegram(gpt_advice, signal.symbol)}"
                    except Exception as e:
                        logger.error(f"–û—à–∏–±–∫–∞ GPT –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è {symbol}: {e}")
            else:
                message = await self.signal_processor.get_detailed_market_status(symbol)
            
            try:
                await loading_message.delete()
            except:
                pass
            
            await query.message.reply_text(message, parse_mode='HTML')
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
            try:
                await loading_message.delete()
            except:
                pass
            await query.message.reply_text(f"‚ùå <b>–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {symbol}</b>", parse_mode='HTML')
    
    async def _get_gpt_analysis_for_signal(self, signal):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ GPT –∞–Ω–∞–ª–∏–∑–∞ –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ —Å –†–ï–ê–õ–¨–ù–´–ú–ò ADX"""
        if not self.gpt_analyzer:
            return None
        
        # –ï—Å–ª–∏ —É –Ω–∞—Å —É–∂–µ –µ—Å—Ç—å –ø–æ–ª–Ω—ã–π GPT –∞–Ω–∞–ª–∏–∑ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
        if hasattr(signal, 'gpt_full_advice') and signal.gpt_full_advice:
            return signal.gpt_full_advice
        
        # –ò–Ω–∞—á–µ —Ñ–æ—Ä–º–∏—Ä—É–µ–º –±–∞–∑–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è GPT
        signal_data = {
            'price': signal.price,
            'ema20': signal.ema20,
            'price_above_ema': signal.price > signal.ema20,
            'conditions_met': True,  # –ï—Å–ª–∏ —É –Ω–∞—Å –µ—Å—Ç—å —Å–∏–≥–Ω–∞–ª, –±–∞–∑–æ–≤—ã–µ —É—Å–ª–æ–≤–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω—ã
        }
        
        # –î–æ–±–∞–≤–ª—è–µ–º –†–ï–ê–õ–¨–ù–´–ï ADX –µ—Å–ª–∏ –µ—Å—Ç—å
        if hasattr(signal, 'adx') and signal.adx > 0:
            signal_data.update({
                'calculated_adx': signal.adx,
                'calculated_plus_di': signal.plus_di,
                'calculated_minus_di': signal.minus_di
            })
        
        try:
            return await self.gpt_analyzer.analyze_signal(
                signal_data, None, is_manual_check=True, symbol=signal.symbol
            )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ GPT –∞–Ω–∞–ª–∏–∑–∞: {e}")
            return None
    
    async def _update_portfolio_message(self, query):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è"""
        try:
            chat_id = query.message.chat_id
            subscriptions = await self.db.get_user_subscriptions(chat_id)
            available_tickers = await self.db.get_available_tickers()
            
            if subscriptions:
                sub_list = [f"üîî {sub['symbol']} ({sub['name']})" for sub in subscriptions]
                message = f"üìä <b>–í–ê–® –ü–û–†–¢–§–ï–õ–¨</b>\n\n<b>–ü–æ–¥–ø–∏—Å–∫–∏:</b>\n" + "\n".join(sub_list)
            else:
                message = "üìä <b>–í–ê–® –ü–û–†–¢–§–ï–õ–¨</b>\n\n<b>–£ –≤–∞—Å –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫</b>"
            
            keyboard = []
            subscribed_symbols = {sub['symbol'] for sub in subscriptions}
            
            for ticker in available_tickers:
                symbol = ticker['symbol']
                name = ticker['name']
                if symbol in subscribed_symbols:
                    button_text = f"üîî {symbol} ({name}) ‚ùå"
                    callback_data = f"unsub_{symbol}"
                else:
                    button_text = f"‚ö™ {symbol} ({name}) ‚ûï"
                    callback_data = f"sub_{symbol}"
                
                keyboard.append([InlineKeyboardButton(button_text, callback_data=callback_data)])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(message, parse_mode='HTML', reply_markup=reply_markup)
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—Ç—Ñ–µ–ª—è: {e}")
